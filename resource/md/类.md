# [类 ( Classes )](https://www.dartlang.org/guides/language/language-tour#classes)

Dart 是一种面向对象编程语言，所有类都源自 Object。Dart 是基于Mixin-based 继承，意思是所有类(除 Object) 只有一个超类，但类主体可以在类的多层次中重用。


## 成员 ( Using class members )

对象有成员由函数和数据(分别为方法和示例变量)组成，可以通过对象实例使用 (.) 进行访问。

代码示例：

```
import 'dart:math';
main() {
  //创建Point对象实例
  var p = Point(2, 2);

  //使用.访问 p 实例的 y 实例变量
  assert(p.y == 2);

  //使用.访问 p 实例 distanceTo
  print(p.distanceTo(Point(3, 4)));

  //使用实例 p + ? 可以防止空指针异常
  print(p?.x);
}
```

[usingClassMembers.dart 代码](../../dart/classes/usingClassMembers.dart)


## 构造器使用 ( Using constructors )

你可以创建一个类的构造器，用 ClassName 作为构造器名称，Dart 也支持自定义构造器名称，用 ClassName.identifier 作为构自定义造器名称，可以有效的解决重载构造器时容易搞混的问题。

代码示例：

```
import 'dart:math';
main() {
  //Dart2 这里可以省略 new 关键字
  var p1 = Point(2, 2);
//  var p1 = new Point(2, 2);//创建对象可以加 new 关键字
  print(p1);
}
```

[usingConstructors.dart 代码](../../dart/classes/usingConstructors.dart)

某些类支持不变的构造器，不变的构造器可以使用 const 关键字进行创建。

示例代码：

```
//对于提供不变的构造器（constant constructors）可以使用 const 构造相同的实例，但必须要保证对比的数据一致
  var p2 = const Point(2, 2);
  var p3 = const Point(2, 2);

  print(identical(p2, p3)); //p2和p3为相同的实例，打印true

  //一个使用const 关键字 和 一个未使用 const 关键字的实例 是不相同的
  var p4 = const Point(1, 1);
  var p5 = Point(1, 1);

  print(identical(p4, p5)); //打印 false
```

[usingConstructors.dart 代码](../../dart/classes/usingConstructors.dart)

使用 const 创建的实例，如果数据一致，则为相同的实例。

## 获取对象运行时的类型 ( Getting an object’s type )

可以使用 Object 的 runtimeType 属性去获取对象运行时的类型。

示例代码：

```
main() {
  String a = "123";

  print("a object type is:${a.runtimeType}"); //使用runtimeType属性获取类型
}
```

[gettingObjectType.dart 代码](../../dart/classes/gettingObjectType.dart)

## 实例变量 ( Instance variables )

类体中声明的变量（非 static）为实例变量，所有未初始化的实例变量值默认为 null ，所有的实例变量都会隐式的生成 getter 方法，非 final 声明的实例变量都会隐式的生成 setter 方法。

示例变量在声明时设置了值，那么它的值是在执行构造器之前执行设置的。

示例代码：

```
main() {
  Foo foo = Foo();

  print("x：${foo.x}，y：${foo.y}，z：${foo.z}");
}

class Foo {
  num x; //声明x ，初始值为：null
  num y; //声明y ，初始值为：null
  num z = 0; //声明z，初始值为：0，该值是在执行构造器之前执行的
}
```

[instanceVariables.dart 代码](../../dart/classes/instanceVariables.dart)

## 构造器声明 ( Constructors )

声明类的构造器非常简单，有以下几点需要了解下：

* 创建一个与类型相同的函数是最常见的声明构造器的形式。
* 如果类未声明构造器，则 Dart 默认会提供一个无参的构造器。
* 构造器是不支持继承的，但支持重载。
* Dart 支持自定义构造器名称，提高多构造函数的清晰度。
* 如果子类存在无参构造器，但父类没有无参构造器，那么子类必须在无参构造器中使用 : super . 或()方式去调用父类的构造器(可以是自命名构造器)
* 构造函数方法断言，可以用于权限判断，但会抛出异常
* 重定向构造器使用关键字  : this()
* factory 关键字，工厂构造器，可以构造出从缓存中获取的实例，该实例可以是子类实例。

声明构造器代码示例：

```
class Foo {
  num x, y;

  //老式写法
//  Foo(num x, num y){
//    this.x = x;
//    this.y = y;
//  }

  //简写
  Foo(this.x, this.y);
  //自定义构造器名
  Foo.origin(this.x, this.y);

  //参照官方网站,构造器可以使用 : 直接为属性赋值
  Foo.fromJson(Map<String, num> json)
      : x = json['x'],
        y = json['y'] {
    //这里是函数体
    print('In Foo.fromJson(): ($x, $y)');
  }

  //参照官方网站 这里使用 : assert断言，看是否有权调用此函数，如果不满足assert条件，则会抛出异常
  Foo.withAssert(this.x, this.y) : assert(x >= 0) {
    print('In Foo.withAssert(): ($x, $y)');
  }
}
```

子类构造器相关示例代码

```
//子类
class Boo extends Foo {
  //调用超类指定构造器
  Boo(num x, num y) : super(x, y);

  //使用this重定向构造器
  Boo.alongXAxis(num x) : this(x, 0);
}

//子类，如果子类存在无参构造器，但父类没有无参构造器，那么子类必须在无参构造器中使用 : super . 或()方式去调用父类的构造器(可以是自命名构造器)
class Coo extends Foo {
//  Coo() : super(1, 1);
//  Coo() : super.origin(2, 2);

  Coo() : super.fromJson({"x": 1, "y": 3});
}
```

不可变构造器代码示例：

```
//不可变的构造器
class ImmutablePoint {
  static final ImmutablePoint origin = const ImmutablePoint(0, 0);

  final num x, y;

  //声明不可变构造器
  const ImmutablePoint(this.x, this.y);
}
```

工厂构造器代码示例：

```
// factory关键字，工厂构造器，
class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to
  // the _ in front of its name.
  static final Map<String, Logger> _cache = <String, Logger>{};//缓存

  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) print(msg);
  }
}
```

[constructors.dart 代码](../../dart/classes/constructors.dart)

## 方法 ( Methods )

方法是对象提供行为的函数。一个方法最好只做一件事，满足单一原则，有利于后期维护。

#### 实例方法

对象的实例方法可以访问实例变量去执行一系列行为。

```
main() {
  //调用实例方法
  Calculate calculate = Calculate();
  print(calculate.plus(5, 5));
}

///实例方法
class Calculate {
  num plus(num a, num b) {
    return a + b;
  }
}
```

#### setter 和 getter方法
setter 和 getter方法 比较特殊，它主要的目的是提供对象属性读和写，这也是面试对象封装的特性。

```
class Rect {
  num left, top, width, height;

  Rect(this.left, this.top, this.width, this.height);

  //getter方法
  num get right => left + width;

  //setter方法
  set right(num value) => left = value - width;

  //getter方法
  num get bottom => top + height;

  //setter方法
  set bottom(num value) => top = value - height;
}
```

[methods.dart 代码](../../dart/classes/methods.dart)


## 抽象方法 ( Abstract methods )

## 抽象类 ( Abstract classes )

## 隐式接口 ( Implicit interfaces )

## 扩展类 ( Extending a class )

## 枚举类型 ( Enumerated types )

## 向类添加功能 ( Adding features to a class: mixins )

## 类的变量和方法 ( Class variables and methods )